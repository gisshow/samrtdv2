{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["ObjectList","id","name","App","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","getBoxIds","linkIds","forEach","item","index","top","document","getElementById","concat","push","key","offsetTop","getBoundingClientRect","setState","scrollToAnchor","anchorName","anchorElement","scrollIntoView","block","behavior","state","b","time","language","arguments","length","undefined","console","log","now","Date","getTime","userAgent","navigator","last","parse","replace","indexOf","subtract","write","yearC","monthC","day","weekC","dayC","hour","hourC","minute","minC","t","split","yy","mm","dd","hh","mmm","parseInt","dateToTimestamp","_this2","scrollRef","scrollTop","classList","add","k","v","remove","_this3","contentOptions","LinkOptions","react_default","a","createElement","className","onClick","bind","style","width","height","border","onScrollCapture","onScrollEvent","overflowY","ref","c","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.8419982d.chunk.js","sourcesContent":["import React, {Component} from 'react';\nimport './App.css';\n\nconst ObjectList =\n    [{id: 1, name: '橘子'},\n    {id: 2, name: '苹果'},\n    {id: 3, name: '香蕉'},\n    {id: 4, name: '菠萝'}];\n\n\n    // 时间戳\nfunction dateToTimestamp (time, language = 'zh_CN') {\n\tconsole.log('a ===> 1')\n  // 刚刚、几分钟前、几小时前、几天前、几周前、（超一周后且当年）月日-时分、年月日-时分\n  const now = new Date().getTime();\n  const { userAgent } = navigator;\n  // const last = new Date(knowledgeInfo.lastUpdateDate).getTime();\n  let last = '';\n  if ('msSaveOrOpenBlob' in navigator) { // 判断是ie的浏览器，调用ie文件下载的方法\n    if (time) {\n      last = new Date(Date.parse(time.replace(/-/g, '/')));\n    }\n  } else if (userAgent.indexOf('Safari') > -1 || userAgent.indexOf('iPhone') > - 1) {\n    if (time) {\n      last = new Date(Date.parse(time.replace(/-/g, '/')));\n    }\n  } else {\n    last = new Date(time).getTime();\n  }\n  // const subtract = (now - last) / (1000 * 60 * 60);  // 这是时间差毫小时\n  const subtract = (now - last); // 这是时间差毫小时\n  document.write('userAgent === ===>' + userAgent);\n  document.write('<br>');\n  document.write('time ===>' + time);\n  document.write('<br>');\n  document.write('last ===>' + last);\n  document.write('<br>');\n  document.write('now ===>' + now);\n  document.write('<br>');\n  document.write('subtract ===>' + subtract);\n  document.write('<br>');\n\n  const minute = 1000 * 60;\n  const hour = minute * 60;\n  const day = hour * 24;\n  const halfamonth = day * 15;\n  const month = day * 30;\n\n  const yearC = subtract / (month * 12);\n  const monthC = subtract / month;\n  const weekC = subtract / (7 * day);\n  const dayC = subtract / day;\n  const hourC = subtract / hour;\n  const minC = subtract / minute;\n\n  const t = time.split(' ');\n  const yy = t[0].split('-')[0];\n  const mm = t[0].split('-')[1];\n  const dd = t[0].split('-')[2];\n  const hh = t[1].split(':')[0];\n  const mmm = t[1].split(':')[1];\n  if (language === 'zh_CN') {\n    if (yearC >= 1) {\n      // return KnowledgeSearchStore.language['create.year.before'].replace('${}', parseInt(yearC, 10));\n      return `${yy}-${mm}-${dd} ${hh}:${mmm}`; // 年月日-时分\n    } if (monthC >= 1) {\n      return `${mm}-${dd} ${hh}:${mmm}`; // 当年的 月日-时分\n    } if (weekC >= 1) {\n      return `${parseInt(weekC, 10)}周前`; // 几周\n    } if (dayC >= 1) {\n      return `${parseInt(dayC, 10)}天前`; // 几天\n    } if (hourC >= 1) {\n      return `${parseInt(hourC, 10)}小时前`; // 小时\n    } if (minC >= 1) {\n      return `${parseInt(minC, 10)}分钟前`; // 分钟\n    }\n    return '刚刚';\n  } else {\n    if (yearC >= 1) {\n      // return KnowledgeSearchStore.language['create.year.before'].replace('${}', parseInt(yearC, 10));\n      return `${yy}-${mm}-${dd} ${hh}:${mmm}`; // 年月日-时分\n    } if (monthC >= 1) {\n      return `${mm}-${dd} ${hh}:${mmm}`; // 当年的 月日-时分\n    } if (weekC >= 1) {\n      return `${parseInt(weekC, 10)} week ago`; // 几周\n    } if (dayC >= 1) {\n      return `${parseInt(dayC, 10)} days ago`; // 几天\n    } if (hourC >= 1) {\n      return `${parseInt(hourC, 10)} hours ago`; // 小时\n    } if (minC >= 1) {\n      return `${parseInt(minC, 10)} minutes ago`; // 分钟\n    }\n    return 'just';\n  }\n};\n\nclass App extends Component{\n\n    constructor(props) {\n        super(props);\n        this.state = {\n\n        };\n    }\n\n\n    componentDidMount() {\n        this.getBoxIds();\n        const b = dateToTimestamp('2020-05-22 18:16:51');\n        document.write(b);\n    }\n\n    /**\n     *  1. 在React生命周期函数中执行函数\n     *  2. 获取每个块的正文内容初始距离浏览器边框的距离 offsetTop\n     */\n    getBoxIds = () => {\n        // 正文板块绑定的id数组\n        const linkIds = [];\n        ObjectList.forEach((item, index) => {\n            const top = document.getElementById(`${item.id}`);\n            if (top) {\n                linkIds.push({ key: item.id, offsetTop: top.getBoundingClientRect().top});\n            }\n        })\n        this.setState({ linkIds });\n    };\n\n\n    // 这是滚动方法\n    scrollToAnchor = (anchorName) => {\n        if (anchorName || anchorName === 0) {\n            // 找到锚点\n            const anchorElement = document.getElementById(anchorName);\n            // 如果对应id的锚点存在，就跳转到锚点\n            if (anchorElement) {\n                anchorElement.scrollIntoView({\n                    block: 'start',\n                    behavior: 'smooth',\n                });\n            }\n        }\n    };\n\n    /**\n     *  activeLink   -- 高亮的类名，属性在css中自行设置\n     *  linkIds    --  锚点对应div id集合的数组\n     *  this.scrollRef.scrollTop  滚动条滚动的距离\n     */\n    onScrollEvent() {\n        const { linkIds } = this.state;\n        linkIds.forEach((item, index) => {\n            if (this.scrollRef.scrollTop > item.offsetTop) {\n                document.getElementById(`link-${item.key}`).classList.add('activeLink');\n                linkIds.forEach((k, v) => {\n                    if (item.key !== k.key) {\n                        document.getElementById(`link-${k.key}`).classList.remove('activeLink');\n                    }\n                });\n            }\n        });\n    }\n\n  render() {\n      const contentOptions = [];\n      const LinkOptions = [];\n      ObjectList.forEach((item) => {\n          LinkOptions.push(<div id={`link-${item.id}`} className=\"link-content\" onClick={this.scrollToAnchor.bind(this, item.id)}>{item.name}</div>)\n          contentOptions.push(\n              <div className=\"content-child\">\n                  <span id={`${item.id}`}>{item.name}</span>\n                  <div style={{ width: '100%', height: 500, border: 'solid 1px red' }}>\n                      我是内容，我是内容\n                  </div>\n              </div>\n          )\n      });\n\n      return (\n          <div className=\"App\">\n              <div\n                  id=\"know-detail-body\"\n                  onScrollCapture={() => this.onScrollEvent()}\n                  style={{ height: 1000, overflowY: 'scroll' }}\n                  ref={(c) => {\n                      this.scrollRef = c;\n                  }}\n              >\n                  <div className=\"content\">\n                      <div id=\"content-div\">\n                          {contentOptions}\n                          <div style={{ width: '100%', height: 500, border: 'solid 1px red' }}>\n                            我是其他内容\n                            我是评论\n                            我是大帅比\n                            给个star吧 哈哈\n                          </div>\n                      </div>\n                  </div>\n\n                  <div className=\"anchor-link-body\" id=\"know-link-anchor\">\n                      <div className=\"link-content-link\">\n                          <span />\n                      </div>\n                      <div id=\"link-contentKey\">\n                          {LinkOptions}\n                      </div>\n                  </div>\n\n              </div>\n          </div>\n      );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}